<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ijw.Next.Collection</name>
    </assembly>
    <members>
        <member name="T:ijw.Next.Collection.ActionWithRefAndIndex`1">
            <summary>
            接受一个Ref对象和行列参数的action委托
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="rowIndex"></param>
            <param name="columnIndex"></param>
        </member>
        <member name="T:ijw.Next.Collection.ArrayEnumerator`1">
            <summary>
            基于一维数组的数组迭代器
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:ijw.Next.Collection.ArrayEnumerator`1._data">
            <summary>
            内部使用的一维数组
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.ArrayEnumerator`1.#ctor(`0[])">
            <summary>
            构造函数, 使用一个一维数组进行初始化
            </summary>
            <param name="Data">一维数组</param>
        </member>
        <member name="P:ijw.Next.Collection.ArrayEnumerator`1.Current">
            <summary>
            当前元素
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.ArrayEnumerator`1.Dispose">
            <summary>
            清理资源
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.ArrayEnumerator`1.MoveNext">
            <summary>
            向后迭代
            </summary>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.ArrayEnumerator`1.Reset">
            <summary>
            复位
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.ArrayExt">
            <summary>
            
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.ArrayExt.NewArrayWithValue``1(System.Array,System.Int32,``0)">
            <summary>
            创建数组, 并使用指定的值填充数组
            </summary>
            <typeparam name="T"></typeparam>
            <param name="a"></param>
            <param name="dimension">数组维度</param>
            <param name="value">指定的值</param>
            <returns>创建好的数组</returns>
        </member>
        <member name="M:ijw.Next.Collection.ArrayExt.NewArrayWithValue``1(System.Array,System.Int32,System.Func{``0})">
            <summary>
            创建数组, 使用指定的函数填充数组.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="a"></param>
            <param name="dimension">数组维度</param>
            <param name="computer">值计算函数, 数组索引作为传入参数</param>
            <returns>创建好的数组</returns>
        </member>
        <member name="M:ijw.Next.Collection.ArrayExt.NewArrayWithValue``1(System.Array,System.Int32,System.Func{System.Int32,``0})">
            <summary>
            创建数组, 使用指定的函数填充数组.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="a"></param>
            <param name="dimension">数组维度</param>
            <param name="computer">值计算函数, 数组索引作为传入参数</param>
            <returns>创建好的数组</returns>
        </member>
        <member name="T:ijw.Next.Collection.ArrayHelper">
            <summary>
            
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.ArrayHelper.NewArrayWithValue``1(System.Int32,``0)">
            <summary>
            创建数组, 并使用指定的值填充数组
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dimension">数组维度</param>
            <param name="value">指定的值</param>
            <returns>创建好的数组</returns>
        </member>
        <member name="M:ijw.Next.Collection.ArrayHelper.NewArrayWithValue``1(System.Int32,System.Func{``0})">
            <summary>
            创建数组, 使用指定的函数填充数组.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dimension">数组维度</param>
            <param name="computer">值计算函数, 数组索引作为传入参数</param>
            <returns>创建好的数组</returns>
        </member>
        <member name="M:ijw.Next.Collection.ArrayHelper.NewArrayWithValue``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            创建数组, 使用指定的函数填充数组.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dimension">数组维度</param>
            <param name="computer">值计算函数, 数组索引作为传入参数</param>
            <returns>创建好的数组</returns>
        </member>
        <member name="M:ijw.Next.Collection.ArrayHelper.ForEachPair``2(``0[],``1[],ijw.Next.ActionWithRef{``0,``1})">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行操作.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="actionWithRef">对每对元素的引用所执行的操作</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">第1个集合的元素数大于第2个集合的元素数时会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="T:ijw.Next.Collection.OneRankArrayExt">
            <summary>
            提供对一维数组的扩展方法
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.OneRankArrayExt.Initialize``1(``0[],System.Func{System.Int32,``0})">
            <summary>
            使用一个初始化函数进行数组的初始化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="initializer"></param>
        </member>
        <member name="M:ijw.Next.Collection.OneRankArrayExt.GetEnumeratorGenerics``1(``0[])">
            <summary>
            获得强类型的枚举器
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.OneRankArrayExt.RemoveAll``1(``0[],``0)">
            <summary>
            以从前向后的顺序, 移除数组中所有具有指定值的元素, 结果将保存在新的数组中返回.
            数组维数不变, 其中可能出现的剩余空间将设为类型的默认值.
            如: 对整形数组{3, 1, 1, 0, 4, 1, 2, 2, 0} 调用 RemoveAll(1) 将得到新数组: {3, 0, 4, 2, 2, 0, 0, 0, 0).
            </summary>
            <typeparam name="T">类型参数</typeparam>
            <param name="source"></param>
            <param name="toRemove">指定的值</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.OneRankArrayExt.ShrinkByRemoving``1(``0[],``0)">
            <summary>
            以从前向后的顺序, 移除数组中所有具有指定值的元素, 结果将保存在新的数组中返回. 新数组维数会发生变化.
            如: 对整形数组{3, 1, 1, 0, 4, 1, 2, 2, 0} 调用 RemoveAll(1) 将得到新数组: {3, 0, 4, 2, 2).
            内部使用了Linq实现.
            </summary>
            <typeparam name="T">类型参数</typeparam>
            <param name="source"></param>
            <param name="toRemove">指定的值</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.OneRankArrayExt.ReplaceAll``1(``0[],``0,``0)">
            <summary>
            对数组中的元素进行替换. 返回新数组.
            </summary>
            <typeparam name="T">类型参数</typeparam>
            <param name="source"></param>
            <param name="replace">要替换的值</param>
            <param name="with">替换成的值</param>
            <returns>新数组</returns>
        </member>
        <member name="M:ijw.Next.Collection.OneRankArrayExt.SetValuesForTheIndexes``1(``0[],System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            根据指定的一系列索引, 设置数组中的值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="index">指定的索引, 一组整数</param>
            <param name="values">指定的值</param>
        </member>
        <member name="M:ijw.Next.Collection.OneRankArrayExt.SetValuesForTheIndexes``1(``0[],System.Collections.Generic.Dictionary{System.Int32,``0})">
            <summary>
            为数组设置指定索引处的值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="values"></param>
        </member>
        <member name="M:ijw.Next.Collection.OneRankArrayExt.Shuffle``1(``0[])">
            <summary>
            随机打乱数组中元素的排列顺序, 返回新数组.
            </summary>
            <param name="numbers"></param>
            <returns></returns>
        </member>
        <member name="T:ijw.Next.Collection.TwoRanksArrayExt">
            <summary>
            提供对二维数组的若干扩展方法
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.ForEach``1(``0[0:,0:],System.Action{``0})">
            <summary>
            对二维数组中每个元素进行迭代, 调用指定操作
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="array"></param>
            <param name="action">指定的操作</param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.ForEachWithIndex``1(``0[0:,0:],System.Action{``0,System.Int32,System.Int32})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="action"></param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.ForEachRow``1(``0[0:,0:],System.Action{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            对二维数组的每一行进行迭代, 调用指定操作
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="array"></param>
            <param name="action">指定的操作, 接受一行作为参数</param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.ForEachColumn``1(``0[0:,0:],System.Action{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
             对二维数组的每一列进行迭代, 调用指定操作
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="array"></param>
            <param name="action">指定操作</param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.SetEach``1(``0[0:,0:],``0)">
            <summary>
            把每个单元格设为指定值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="value">指定值</param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.SetEach``1(``0[0:,0:],System.Func{System.Int32,System.Int32,``0})">
            <summary>
            根据指定的方法设置每个单元格中的值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="function"></param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.SetEachRow``1(``0[0:,0:],System.Func{``0[],``0[]})">
            <summary>
            对每一行使用指定的函数进行变换
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="function">变换函数, 接受一行, 返回一组新值</param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.SetEachColumn``1(``0[0:,0:],System.Func{``0[],``0[]})">
            <summary>
            对每一列使用指定的函数进行变换
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="function">变换函数, 接受一列, 返回一组新值</param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.Clear``1(``0[0:,0:])">
            <summary>
            清空数组
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.GetRowAt``1(``0[0:,0:],System.Int32)">
            <summary>
            获取二维数组的某一行
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="index">行号</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.GetColumnAt``1(``0[0:,0:],System.Int32)">
            <summary>
            获取二维数组的某一列
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="index">列号</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.SetRowAt``1(``0[0:,0:],System.Int32,``0[])">
            <summary>
            用指定数组的值替换掉数组中某一行
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="index">行索引</param>
            <param name="value">给定的数组</param>
        </member>
        <member name="M:ijw.Next.Collection.TwoRanksArrayExt.SetColumnAt``1(``0[0:,0:],System.Int32,``0[])">
            <summary>
            用指定数组的值替换掉数组中某一列
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="index">列索引</param>
            <param name="value">给定的数组</param>
        </member>
        <member name="T:ijw.Next.Collection.CollectionDividingMethod">
            <summary>
            获取子集的方法, 隔行或者是随机抽取
            </summary>
        </member>
        <member name="F:ijw.Next.Collection.CollectionDividingMethod.EachTheOtherLine">
            <summary>
            每隔一行
            </summary>
        </member>
        <member name="F:ijw.Next.Collection.CollectionDividingMethod.Random">
            <summary>
            随机
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.CountNotMatchException">
            <summary>
            表示多个集合的元素数量不匹配的异常
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.CountNotMatchException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.FetchingStrategies">
            <summary>
            取回策略
            </summary>
        </member>
        <member name="F:ijw.Next.Collection.FetchingStrategies.FirstFirst">
            <summary>
            第一个优先
            </summary>
        </member>
        <member name="F:ijw.Next.Collection.FetchingStrategies.LastFirst">
            <summary>
            最后一个优先
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.ICollectionExt">
            <summary>
            对ICollection{T}的一些扩展方法
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.ICollectionExt.DivideByRatioAndMethod``1(System.Collections.Generic.ICollection{``0},System.Int32,System.Int32,ijw.Next.Collection.CollectionDividingMethod,System.Collections.Generic.IList{``0}@,System.Collections.Generic.IList{``0}@)">
            <summary>
            将一个集合分割为两个集合
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="ratioOfFirstGroup">一个整数, 第一个集合占的比例</param>
            <param name="ratioOfSecondGroup">一个整数, 第二个集合占的比例</param>
            <param name="method">分割方法</param>
            <param name="firstGroup">第一个集合</param>
            <param name="secondGroup">第二个集合</param>
            <remarks>
            Returning IList is bad design, so this is not recommended in net40+, use tuple-returning instead.
            </remarks>
        </member>
        <member name="M:ijw.Next.Collection.ICollectionExt.DivideByRatioAndMethod``1(System.Collections.Generic.ICollection{``0},ijw.Next.Collection.CollectionDividingMethod,System.Int32,System.Int32)">
            <summary>
            将一个集合分割为两个集合
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="method">分割方法</param>
            <param name="ratioOfFirstGroup">一个整数, 第一个集合占的比例</param>
            <param name="ratioOfSecondGroup">一个整数, 第二个集合占的比例</param>
            <returns></returns>
        </member>
        <member name="T:ijw.Next.Collection.EnumerableBase`1">
            <summary>
            可枚举对象基类, 不可以实例化该类.可以从此类继承, 从而方便地利用定长数组实现IEnumerable{T}.
            通过在内部使用数组T[], 提供了一个最小的IEnumerable{T}实现.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ijw.Next.Collection.EnumerableBase`1.#ctor">
            <summary>
            构造一个可枚举对象
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.EnumerableBase`1.#ctor(System.Int32)">
            <summary>
            给定长度, 构造一个可枚举对象.
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.EnumerableBase`1.#ctor(`0[])">
            <summary>
            构造一个可枚举对象, 使用指定的数组初始化.
            </summary>
            <param name="data">用于初始化的数组.内部将直接引用这个数组.</param>
        </member>
        <member name="M:ijw.Next.Collection.EnumerableBase`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            构造一个可枚举对象, 使用一个IEnumerable{T}初始化.
            </summary>
            <param name="data">用于初始化的集合. EnumerableBase将拷贝这个集合.</param>
        </member>
        <member name="F:ijw.Next.Collection.EnumerableBase`1._data">
            <summary>
            内部数组
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.EnumerableBase`1.GetEnumerator">
            <summary>
            获取一个迭代器(由内部数组实现)
            </summary>
            <returns></returns>
        </member>
        <member name="T:ijw.Next.Collection.IEnumerableExt">
            <summary>
            提供了IEnumerable的一系列扩展方法
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            在集合上遍历执行指定操作. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="action">调用的函数</param>
            <returns>集合元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            在集合上遍历执行指定操作, 提供元素和索引同时作为参数, 索引从0开始.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="action"></param>
            <returns>集合的元素个数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            在集合上遍历调用某个函数.函数返回值可以控制是否继续迭代.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="doWhile">调用的函数, 返回false则不继续迭代</param>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            在集合上遍历调用某个函数, 提供元素和索引同时作为参数, 索引从0开始. 函数返回值可以控制是否break循环.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="doWhile">返回TRUE继续循环, 返回false则break退出</param>
            <returns>执行到元素的索引</returns>
            <remarks>
            <para>与TakeWhile有一定差别：本函数直接运行，不返回迭代器。</para>
            </remarks>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachWindow``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            根据指定长度迭代返回每一个窗口。例如{a,b,c,d,e,f}.ForEachWindow(3)将依次返回数组：[a,b,c]、[b,c,d]、[c,d,e]、[d,e,f].
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="windowLength">指定长度</param>
            <returns>窗口序列</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachAndNext``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            遍历返回每一个元素和下一个元素组成的元组.例如对于集合[a,b,c,d], 则遍历返回(a,b)、(b,c)、(c,d).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns>返回每一个和下一个组成的元组</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachAndNext``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,``0})">
            <summary>
            对集合中的每一个元素和下一个元素执行指定操作.例如对于集合[a,b,c,d]指定action, 则遍历执行action(a,b)、action(b,c)、action(c,d).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="action">指定的操作, 接受两个参数</param>
            <returns>最后执行处的元素索引.-1表示没有执行.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachAndNext``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,``0,System.Int32})">
            <summary>
            对每一个元素和下一个元素以及前者的索引执行指定操作.例如对于集合[a,b,c,d]指定action, 则遍历执行action(a,b,0)、action(b,c,1)、action(c,d,2).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="action">指定的操作, 接受两个参数</param>
            <returns>最后执行处的元素索引.-1表示没有执行.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachAndNext``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1})">
            <summary>
            对每一个元素和下一个元素调用指定函数.例如对于集合[a,b,c,d]指定func, 则遍历调用func(a,b)、func(b,c)、func(c,d).
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="collection"></param>
            <param name="func">指定的函数, 接受两个参数</param>
            <returns>计算结果组成的序列</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachAndNext``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Int32,``1})">
            <summary>
            对每一个元素和下一个元素以及前者的索引调用指定函数.例如对于集合[a,b,c,d]指定func, 则遍历调用func(a,b,0)、func(b,c,1)、func(c,d,2).
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="collection"></param>
            <param name="func">指定的函数, 接受三个参数</param>
            <returns>计算结果组成的序列</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachAndNextWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            对每一个元素和下一个元素执行指定操作.操作返回值控制是否继续遍历.例如对于集合[a,b,c,d]指定func, 则遍历调用func(a,b,0)、func(b,c,1)、func(c,d,2).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="doWhile">指定的函数, 接受2个元素类型参数, 返回false则停止迭代</param>
            <returns>最后执行处的元素索引(连续两元素的第一个元素的索引), -1表示没有执行.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ForEachAndNextWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Int32,System.Boolean})">
            <summary>
            对每一个元素和下一个元素以及前者的索引调用指定函数.例如对于集合[a,b,c,d]指定func, 则遍历调用func(a,b,0)、func(b,c,1)、func(c,d,2).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="doWhile">指定的函数, 接受三个参数, 返回false则停止迭代</param>
            <returns>最后执行处的元素索引(连续两元素的第一个元素的索引), -1表示没有执行.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ItemEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            元素值比较.即依次调用Equals方法比较数组中每个元素是否相等.
            </summary>
            <param name="source"></param>
            <param name="other"></param>
            <returns>元素数量相等且每个元素相等, 返回true, 否则返回false.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ItemEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            调用指定函数元素值比较.即依次调用指定接口比较数组中每个元素是否相等.
            </summary>
            <param name="source"></param>
            <param name="other"></param>
            <param name="comparer">用于比较相等</param>
            <returns>元素数量相等且每个元素相等, 返回true, 否则返回false.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ItemEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            调用指定函数元素值比较.即依次调用指定方法比较数组中每个元素是否相等.
            </summary>
            <param name="source"></param>
            <param name="other"></param>
            <param name="comparer">指定的用于比较相等的方法</param>
            <returns>元素数量相等且每个元素相等, 返回true, 否则返回false.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ItemEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Int32,System.Boolean})">
            <summary>
            调用指定函数元素值比较.即依次调用指定方法比较数组中每个元素是否相等.
            </summary>
            <param name="source"></param>
            <param name="other"></param>
            <param name="comparer">指定的用于比较相等的方法</param>
            <returns>元素数量相等且每个元素相等, 返回true, 否则返回false.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            调用指定函数元素值比较.即依次调用指定方法比较数组中每个元素是否相等.
            </summary>
            <param name="source"></param>
            <param name="other"></param>
            <param name="comparer">指定的用于比较相等的方法</param>
            <returns>元素数量相等且每个元素相等, 返回true, 否则返回false.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Int32,System.Boolean})">
            <summary>
            调用指定函数元素值比较.即依次调用指定方法比较数组中每个元素是否相等.
            </summary>
            <param name="source"></param>
            <param name="other"></param>
            <param name="comparer">指定的用于比较相等的方法</param>
            <returns>元素数量相等且每个元素相等, 返回true, 否则返回false.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            给定起止索引, 提取范围内的元素, 包括起止处的元素.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="fromIndex">起始索引</param>
            <param name="toIndex">终止索引</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.TakeEveryOther``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            从0开始反复提取指定数目的元素, 每次增加指定步长.提取元素形成新集合, 内部使用了yield return.
            如果步长和提取量相等, 则元素全部被提取.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="step">步长, 每隔多少个元素进行提取, 1代表相邻的下一个. 例如step设为2, 则每次提取的起始索引是：0, 2, 4...</param>
            <param name="takeEachTime">每次提取量, 应小于等于步长</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.TakePythonStyle``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            类python风格的取子集. 如: 对[1,2,3,4,5], <see cref="M:ijw.Next.Collection.IEnumerableExt.TakePythonStyle``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})"/>(0, -1)返回[1,2,3,4]; <see cref="M:ijw.Next.Collection.IEnumerableExt.TakePythonStyle``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})"/>(-3, -1)返回[3, 4]; <see cref="M:ijw.Next.Collection.IEnumerableExt.TakePythonStyle``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Int32},System.Nullable{System.Int32})"/>(1,2)返回[2]
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="startAt">启始索引. 该处元素将包括在返回结果中. 0 = 第一个元素, -n = 倒数第n个元素, null = 0. 默认值是0</param>
            <param name="endAt">结束索引. 该处元素将不包括在返回结果中. 0 = 第一个元素, -n = 倒数第n个元素, null = 结尾. 默认值为null. </param>
            <returns>子集</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.GetCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            获取集合中的元素数量（主要考虑IIndexable）
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns>集合中的元素数量</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            查找指定元素在集合第一次出现位置的索引
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="collection"></param>
            <param name="value">指定元素</param>
            <returns>如果集合中不存在, 返回-1;</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            在IEnumerable&lt;T&gt;查找第一个符合谓词的元素对象的索引
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="collection">集合</param>
            <param name="predicate">谓词, 为真则立即返回索引</param>
            <returns>返回第一个符合谓词的元素的索引, 如果没有符合的将会返回-1</returns>
            <remarks>
            方法从后向前遍历集合, 因此时间复杂度是O(index), 即如果目标元素是第一个, 则只需要一次迭代.
            此方法适用于预期元素处于列表中排位靠后的情况. 如果预期元素在较前的位置, 应该使用LastIndexOf&lt;T&gt;扩展方法.
            </remarks>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.LastIndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            在IEnumerable&lt;T&gt;查找最后一个出现的元素对象索引
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ElementsAt``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            从集合中按指定索引处, 提取相应的元素们形成新的集合. （输出按照元素在集合中的顺序, 而非指定索引的顺序）
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="indexes">指定的索引, 一组整数</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.GetElementsAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            提取集合中指定索引处的元素
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="index">指定的索引</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.EachWithIndex``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            返回一个由元素及其相应索引组成的元组集合
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.DivideByRatio``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Collections.Generic.List{``0}@,System.Collections.Generic.List{``0}@)">
            <summary>
            按指定的比例把集合分拆成两部分
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="source">源集合</param>
            <param name="ratioOfFirstGroup">第一部分的占比</param>
            <param name="ratioOfSecondGroup">第二部分的占比</param>
            <param name="firstGroup">分拆出的第一部分</param>
            <param name="secondGroup">分拆出的第二部分</param>
            <remarks>net40+请使用返回元组的版本,  out return 版本不推荐使用</remarks>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.DivideByRatioAndMethod``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,ijw.Next.Collection.CollectionDividingMethod,System.Collections.Generic.List{``0}@,System.Collections.Generic.List{``0}@)">
            <summary>
            把一个集合按指定的比率和方式分成两部分
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="source">源集合</param>
            <param name="method">切分方式</param>
            <param name="ratioOfFirstGroup">第一部分的比例</param>
            <param name="ratioOfSecondGroup">第二把部分的比例</param>
            <param name="firstGroup">切分后的第一部分</param>
            <param name="secondGroup">切分后的第二部分</param>
            <remarks>net40+请使用返回元组的版本,  out return 版本不推荐使用</remarks>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.DivideByRatio``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            按指定的比例把集合分拆成两部分
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="source">源集合</param>
            <param name="ratioOfFirstGroup">第一部分的占比</param>
            <param name="ratioOfSecondGroup">第二部分的占比</param>
            <returns>元组（分拆出的第一部分, 分拆出的第二部分）</returns>
            <remarks>使用返回元组的版本,  out return 版本不推荐使用</remarks>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.DivideByRatioAndMethod``1(System.Collections.Generic.IEnumerable{``0},ijw.Next.Collection.CollectionDividingMethod,System.Int32,System.Int32)">
            <summary>
            把一个集合按指定的比率和方式分成两部分
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="source">源集合</param>
            <param name="method">切分方式</param>
            <param name="ratioOfFirstGroup">第一部分的比例</param>
            <param name="ratioOfSecondGroup">第二把部分的比例</param>
            <returns>元组（切分后的第一部分, 切分后的第二部分）</returns>
            <remarks>使用返回元组的版本,  out return 版本不推荐使用</remarks>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.Shuffle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            返回随机打乱顺序的序列. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns>随机打乱顺序后的序列</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            返回第一个满足条件的元素, 过滤条件使用元素和索引作为参数.无则抛出<see cref="T:System.InvalidOperationException"/>异常.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="pred"></param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            返回第一个满足条件的元素, 过滤条件使用元素和索引作为参数.无则返回null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="pred">过滤条件, 为真则返回.</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>
            用元素和索引作为参数, 使用指定的方法比较, 找到最大值
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="collection"></param>
            <param name="func">比较的方法, 接受元素及其索引作为参数.</param>
            <returns>最大值及其索引</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>
            用元素和索引作为参数, 使用指定的方法比较, 找到最大值
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="collection"></param>
            <param name="func">比较的方法, 接受元素及其索引作为参数.</param>
            <returns>最小值及其索引</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SumAndCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            用元素作为参数, 使用指定的方法计算后, 求和
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="func">计算的方法, 接受元素及其索引作为参数.</param>
            <returns>所求到和与进行求和的元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SumAndCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            用元素作为参数, 使用指定的方法计算后, 求和
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="func">计算的方法, 接受元素及其索引作为参数.</param>
            <returns>所求到和与进行求和的元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SumAndCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            用元素作为参数, 使用指定的方法计算后, 求和
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="func">计算的方法, 接受元素及其索引作为参数.</param>
            <returns>所求到和与进行求和的元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SumAndCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            用元素作为参数, 使用指定的方法计算后, 求和
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="func">计算的方法, 接受元素及其索引作为参数.</param>
            <returns>所求到和与进行求和的元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SumAndCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Double})">
            <summary>
            用元素和索引作为参数, 使用指定的方法计算后, 求和
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="func">计算的方法, 接受元素及其索引作为参数.</param>
            <returns>所求到和与进行求和的元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SumAndCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Single})">
            <summary>
            用元素和索引作为参数, 使用指定的方法计算后, 求和
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="func">计算的方法, 接受元素及其索引作为参数.</param>
            <returns>所求到和与进行求和的元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SumAndCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Int32})">
            <summary>
            用元素和索引作为参数, 使用指定的方法计算后, 求和
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="func">计算的方法, 接受元素及其索引作为参数.</param>
            <returns>所求到和与进行求和的元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.SumAndCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Int64})">
            <summary>
            用元素和索引作为参数, 使用指定的方法计算后, 求和
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="func">计算的方法, 接受元素及其索引作为参数.</param>
            <returns>所求到和与进行求和的元素总数</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ToSimpleEnumStrings``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.String,System.String,System.String)">
            <summary>
            输出形如[a1, a2 ... an]的带省略号的字符串
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="maxDisplayNumber">字符串中最多显示几个元素</param>
            <param name="postfix">前缀字符串, 显示在第一个元素前面的字符串</param>
            <param name="prefix">后缀字符串, 显示在最后一个元素后面的字符串</param>
            <param name="seperator">每个元素之间的分割字符串</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableExt.ToAllEnumStrings``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String,System.Func{``0,System.String})">
            <summary>
            输出包含所有元素的字符串, 默认形如[a1, a2, a3, [a41, a42, a43], a5]
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="separator">元素之间的分隔符, 默认是", "</param>
            <param name="prefix">第一个元素之前的字符串, 默认是"["</param>
            <param name="postfix">最后一个元素之后的字符串, 默认是"]"</param>
            <param name="transform">对于每个元素, 输出字符串之前进行一个操作.默认为null, 代表调用ToString().</param>
            <returns></returns>
        </member>
        <member name="T:ijw.Next.Collection.IEnumerableHelper">
            <summary>
            集合操作的帮助类
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachPair``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Action{``0,``1},System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行操作.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="action">需要对每对元素执行的操作，接受两个集合的元素对作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachPair``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Action{``0,``1,System.Int32},System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行操作. 当前索引将作为参数之一。
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="action">需要对每对元素执行的操作，接受两个集合的元素对以及当前索引作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachPairSelect``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2},System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行指定函数计算（延迟）, 返回迭代器.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <typeparam name="TResult">函数计算返回值得类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="func">执行计算的函数，接受两个集合的元素对作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <returns>返回的结果迭代器</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
            <remarks>本函数返回时指定函数计算并没有进行, 本函数只返回一个迭代器.计算将延迟在对结果的迭代访问时进行.</remarks>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachPairSelect``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,System.Int32,``2},System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行指定函数计算（延迟）, 返回迭代器.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <typeparam name="TResult">函数计算返回值得类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="func">执行计算的函数，接受两个集合的元素对以及当前索引作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <returns>返回的结果迭代器</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">第1个集合的元素数大于第2个集合的元素数时会抛出 CountNotMatchException 异常.</exception>
            <remarks>本函数返回时指定函数计算并没有进行, 本函数只返回一个迭代器.计算将延迟在对结果的迭代访问时进行.</remarks>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachPairWhile``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,System.Boolean},System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行指定的操作. 根据操作返回的值决定是否提前结束迭代.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="dowhile">需要对每对元素执行的操作，接受两个集合的元素对作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
            <returns>迭代的次数.注意如果迭代是在到达第1个集合结尾之前就break出来的话，此项为相应的负值。因此可通过返回值的正负来判断是否进行完整的迭代。</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachPairWhile``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,System.Int32,System.Boolean},System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行操作.根据操作返回的值决定是否提前结束迭代.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="dowhile">需要对每对元素执行的操作，接受两个集合的元素对以及当前索引作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <returns>迭代的次数. 注意如果迭代是在到达第1个集合结尾之前就break出来的话，此项为相应的负值。因此可通过返回值的正负来判断是否进行完整的迭代。</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachTwoInBetween``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Action{``0,``1})">
            <summary>
            针对每个来自两个集合的元素对执行指定操作. 例如对于{1,2}和{a,b,c}, 将依次针对(1,a), (1,b), (1,c), (2,a), (2,b), (2,c)六种组合执行操作.
            <para>
            可以理解为嵌套for循环.
            </para>
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="collection1">第一个集合</param>
            <param name="collection2">第二个集合</param>
            <param name="action">想要执行的操作. 接受两个参数, 第一个参数来自第一个集合, 第二个参数来自第二个集合.</param>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachTwoInBetween``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            对元组中两个集合的每一对组合对执行指定查询. 例如对于{1,2}和{a,b,c}, 将依次针对(1,a), (1,b), (1,c), (2,a), (2,b), (2,c)六种组合执行操作.
            <para>
            可以理解为嵌套for循环.
            </para>
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult">函数计算返回值得类型</typeparam>
            <param name="collection1">第一个集合</param>
            <param name="collection2">第二个集合</param>
            <param name="func">想要执行的计算. 接受两个参数, 第一个参数来自第一个集合, 第二个参数来自第二个集合.</param>
            <returns>每一个组合的计算结果组成的序列迭代器.</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachThree``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Action{``0,``1,``2})">
            <summary>
            对三个集合进行同步迭代, 对每一组（三个）元素进行指定操作.
            </summary>
            <typeparam name="T1">第一个集合里面元素的类型</typeparam>
            <typeparam name="T2">第二个个集合里面元素的类型</typeparam>
            <typeparam name="T3">第三个个集合里面元素的类型</typeparam>
            <param name="collection1">第一个集合</param>
            <param name="collection2">另二个集合</param>
            <param name="collection3">第三个集合</param>
            <param name="doWork">执行的操作</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">集合1元素数大于集合2或集合3的元素数时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachThree``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Action{``0,``1,``2,System.Int32})">
            <summary>
            对三个集合进行同步迭代, 对每一组（三个）元素及其索引进行指定操作.
            </summary>
            <typeparam name="T1">第一个集合里面元素的类型</typeparam>
            <typeparam name="T2">第二个个集合里面元素的类型</typeparam>
            <typeparam name="T3">第三个个集合里面元素的类型</typeparam>
            <param name="collection1">第一个集合</param>
            <param name="collection2">另二个集合</param>
            <param name="collection3">第三个集合</param>
            <param name="doWork">执行的操作</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">集合1元素数大于集合2或集合3的元素数时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableHelper.ForEachThreeSelect``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            对三个集合进行同步迭代, 对每一组（三个）元素进行指定函数计算
            </summary>
            <typeparam name="T1">第一个集合里面元素的类型</typeparam>
            <typeparam name="T2">第二个个集合里面元素的类型</typeparam>
            <typeparam name="T3">第三个个集合里面元素的类型</typeparam>
            <typeparam name="TResult">函数计算返回值得类型</typeparam>
            <param name="collection1">第一个集合</param>
            <param name="collection2">另二个集合</param>
            <param name="collection3">第三个集合</param>
            <param name="theFunction">需要计算的函数</param>
            <returns>返回的结果迭代器</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">集合1元素数大于集合2或集合3的元素数时, 会抛出 CountNotMatchException 异常.</exception>
            <remarks>
            本函数只返回一个迭代器.计算将延迟在对结果的迭代访问时进行.
            </remarks>
        </member>
        <member name="T:ijw.Next.Collection.IEnumerableNumberExt">
            <summary>
            
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.Average(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)">
            <summary>
            计算均值，可指定是否忽略最大值最小值
            </summary>
            <param name="values"></param>
            <param name="ignoreMaxMinValue">是否忽略最大值最小值</param>
            <returns>均值</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.Average(System.Collections.Generic.IEnumerable{System.Single},System.Boolean)">
            <summary>
            计算均值，可指定是否忽略最大值最小值
            </summary>
            <param name="values"></param>
            <param name="ignoreMaxMinValue">是否忽略最大值最小值</param>
            <returns>均值</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.GetVariance(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)">
            <summary>
            获得方差
            </summary>
            <param name="values"></param>
            <param name="isAllData">是否是全部数据. true则分母是数据集count，反之是count-1.</param>
            <returns>方差</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.GetVariance(System.Collections.Generic.IEnumerable{System.Single},System.Boolean)">
            <summary>
            获得方差
            </summary>
            <param name="values"></param>
            <param name="isAllData">是否是全部数据. true则分母是数据集count，反之是count-1.</param>
            <returns>方差</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.GetStandardVariance(System.Collections.Generic.IEnumerable{System.Double},System.Boolean)">
            <summary>
            获得标准差
            </summary>
            <param name="values"></param>
            <param name="isAllData">是否是全部数据. true则分母是数据集count，反之是count-1.</param>
            <returns>方差</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.GetStandardVariance(System.Collections.Generic.IEnumerable{System.Single},System.Boolean)">
            <summary>
            获得标准差
            </summary>
            <param name="values"></param>
            <param name="isAllData">是否是全部数据. true则分母是数据集count，反之是count-1.</param>
            <returns>方差</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.GetMedianValue(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            获取集合的中位值。
            </summary>
            <param name="values"></param>
            <returns>奇数个元素，返回中间元素的值，偶数个元素返回中间两元素的平均值。</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.GetMedianValue(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            获取集合的中位值。
            </summary>
            <param name="values"></param>
            <returns>奇数个元素，返回中间元素的值，偶数个元素返回中间两元素的平均值。</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.GetMiddleValue(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            获取集合的中值。
            </summary>
            <param name="values"></param>
            <returns>返回最大最小的平均值。</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.GetMiddleValue(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            获取集合的中值。
            </summary>
            <param name="values"></param>
            <returns>返回最大最小的平均值。</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.Normalize(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            对浮点集合中的值逐一进行归一化
            </summary>
            <param name="collection">浮点数集合</param>
            <param name="maxValues">归一化上限值的集合</param>
            <param name="minValues">归一化下限值的集合</param>
            <returns>归一化后的集合</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.Normalize(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            对浮点集合中的值逐一进行归一化
            </summary>
            <param name="collection">浮点数集合</param>
            <param name="maxValues">归一化上限值的集合</param>
            <param name="minValues">归一化下限值的集合</param>
            <returns>归一化后的集合</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.Denormalize(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            对浮点集合中的值逐一进行反归一化
            </summary>
            <param name="collection">浮点数集合</param>
            <param name="maxValues">归一化上限值的集合</param>
            <param name="minValues">归一化下限值的集合</param>
            <returns>反归一化后的集合</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberExt.Denormalize(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            对浮点集合中的值逐一进行反归一化
            </summary>
            <param name="collection">浮点数集合</param>
            <param name="maxValues">归一化上限值的集合</param>
            <param name="minValues">归一化下限值的集合</param>
            <returns>反归一化后的集合</returns>
        </member>
        <member name="T:ijw.Next.Collection.IEnumerableNumberFilterExt">
            <summary>
            
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberFilterExt.LimitingDiffFilter(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            限制波动对集合进行过滤. 用前一个样本+波动幅度代替. 
            </summary>
            <param name="values">原集合</param>
            <param name="diff">波动幅度限制</param>
            <return>过滤后的新集合</return>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberFilterExt.LimitingDiffFilter(System.Collections.Generic.IEnumerable{System.Single},System.Single)">
            <summary>
            限制波动对集合进行过滤. 用前一个样本+波动幅度代替. 
            </summary>
            <param name="values">原集合</param>
            <param name="diff">波动幅度限制</param>
            <return>过滤后的新集合</return>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberFilterExt.LimitingAmplifyFilter(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            限幅过滤. 放弃掉波动过大的数值, 用前一个数值代替. 
            </summary>
            <param name="values">原集合</param>
            <param name="diff">波动最大值绝对值</param>
            <returns>过滤后的新集合</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberFilterExt.LimitingAmplifyFilter(System.Collections.Generic.IEnumerable{System.Single},System.Single)">
            <summary>
            限幅过滤. 放弃掉波动过大的数值, 用前一个数值代替. 
            </summary>
            <param name="values">原集合</param>
            <param name="diff">波动最大值绝对值</param>
            <returns>过滤后的新集合</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberFilterExt.MedianFilter(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            在指定窗口长度内进行中位值滤波。例如{1,2,8,5}.MedianFilter(3), 返回:{1,2,5,5}.
            </summary>
            <param name="values">原集合</param>
            <param name="windowLength">窗口长度</param>
            <returns>新的样本集</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberFilterExt.MedianFilter(System.Collections.Generic.IEnumerable{System.Single},System.Int32)">
            <summary>
            在指定窗口长度内进行中位值滤波。例如{1,2,8,5}.MedianFilter(3), 返回:{1,2,5,5}.
            </summary>
            <param name="values">原集合</param>
            <param name="windowLength">窗口长度</param>
            <returns>新的样本集</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberFilterExt.MeanFilter(System.Collections.Generic.IEnumerable{System.Double},System.Int32,System.Boolean)">
            <summary>
            算术平均值过滤. 窗口长度内取平均值.
            </summary>
            <param name="values">原集合</param>
            <param name="windowLength">窗口长度</param>
            <param name="ignoreMaxMinValue">计算均值时是否忽略最大值最小值</param>
            <returns>新的样本集</returns>
        </member>
        <member name="M:ijw.Next.Collection.IEnumerableNumberFilterExt.MeanFilter(System.Collections.Generic.IEnumerable{System.Single},System.Int32,System.Boolean)">
            <summary>
            算术平均值过滤. 窗口长度内取平均值.
            </summary>
            <param name="values">原集合</param>
            <param name="windowLength">窗口长度</param>
            <param name="ignoreMaxMinValue">计算均值时是否忽略最大值最小值</param>
            <returns>新的样本集</returns>
        </member>
        <member name="T:ijw.Next.Collection.IIndexable`1">
            <summary>
            带有索引器的集合
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:ijw.Next.Collection.IIndexable`1.Item(System.Int32)">
            <summary>
            索引器
            </summary>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="P:ijw.Next.Collection.IIndexable`1.Count">
            <summary>
            集合元素数量
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.IIndexableExt">
            <summary>
            
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.LimitingDiffFilter(ijw.Next.Collection.IIndexable{System.Double},System.Double)">
            <summary>
            限制波动对集合进行过滤. 用前一个样本+波动幅度代替. 
            </summary>
            <param name="values">原集合</param>
            <param name="diff">波动幅度限制</param>
            <return>过滤后的新集合</return>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.LimitingAmplifyFilter(ijw.Next.Collection.IIndexable{System.Double},System.Double)">
            <summary>
            限幅过滤. 放弃掉波动过大的数值, 用前一个数值代替. 
            </summary>
            <param name="values">原集合</param>
            <param name="diff">波动最大值绝对值</param>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.MedianFilter(ijw.Next.Collection.IIndexable{System.Double},System.Int32)">
            <summary>
            中位值过滤. 窗口长度内取中位值
            </summary>
            <param name="values">原集合</param>
            <param name="windowLength">窗口长度</param>
            <returns>新的样本集</returns>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.MeanFilter(ijw.Next.Collection.IIndexable{System.Double},System.Int32)">
            <summary>
            算术平均值过滤. 窗口长度内取平均值
            </summary>
            <param name="values">原集合</param>
            <param name="windowLength">窗口长度</param>
            <returns>新的样本集</returns>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.GetEnumeratorForIIndexable``1(ijw.Next.Collection.IIndexable{``0})">
            <summary>
            获得一个枚举器
            </summary>
            <typeparam name="T"></typeparam>
            <param name="indexable"></param>
            <returns></returns>
        </member>
        <member name="T:ijw.Next.Collection.IIndexableExt.IIndexableEnumerator`1">
            <summary>
            可索引集合的枚举器
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.IIndexableEnumerator`1.#ctor(ijw.Next.Collection.IIndexable{`0})">
            <summary>
            构造函数
            </summary>
            <param name="indexable"></param>
        </member>
        <member name="P:ijw.Next.Collection.IIndexableExt.IIndexableEnumerator`1.Current">
            <summary>
            当前元素
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.IIndexableEnumerator`1.Dispose">
            <summary>
            清理资源
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.IIndexableEnumerator`1.MoveNext">
            <summary>
            迭代
            </summary>
            <returns></returns>
        </member>
        <member name="M:ijw.Next.Collection.IIndexableExt.IIndexableEnumerator`1.Reset">
            <summary>
            复位
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.Indexable`1">
            <summary>
            带索引的列表.内部用定长数组实现.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ijw.Next.Collection.Indexable`1.#ctor(System.Int32)">
            <summary>
            给定长度进行初始化
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:ijw.Next.Collection.Indexable`1.#ctor(`0[])">
            <summary>
            使用一个数组进行初始化
            </summary>
            <param name="data">进行初始化的一维数组</param>
        </member>
        <member name="M:ijw.Next.Collection.Indexable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            使用一个集合进行初始化
            </summary>
            <param name="data">进行初始化的集合</param>
        </member>
        <member name="P:ijw.Next.Collection.Indexable`1.Item(System.Int32)">
            <summary>
            索引器
            </summary>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="P:ijw.Next.Collection.Indexable`1.Count">
            <summary>
            集合元素总数
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.IndexableList`1">
            <summary>
            实现Indexable的List{T}
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ijw.Next.Collection.IListExt">
            <summary>
            提供了IList接口的一系列扩展方法
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IListExt.IndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            在IList集合中查找第一个符合谓词的元素对象的索引
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="collection">集合</param>
            <param name="predicate">谓词, 为真则立即返回索引</param>
            <returns>返回第一个符合谓词的元素的索引, 如果没有符合的将会返回-1</returns>
            <remarks>
            方法从前向后遍历列表, 因此时间复杂度是O(index), 即如果目标元素是第一个, 则只需要一次迭代.
            此方法适用于预期元素处于列表中排位靠前的情况. 如果预期元素在较后的位置, 应该使用LastIndexOf&lt;T&gt;扩展方法.
            </remarks>
        </member>
        <member name="M:ijw.Next.Collection.IListExt.LastIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            在IList集合中查找最后一个符合谓词的元素对象的索引
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="collection">集合</param>
            <param name="predicate">谓词, 为真则立即返回索引</param>
            <returns>返回最后一个符合谓词的元素的索引, 如果没有符合的将会返回-1</returns>
            <remarks>
            方法从后向前遍历列表, 因此时间复杂度是O(count-index), 即如果目标元素是最后一个, 则只需要一次迭代.
            此方法适用于预期元素处于列表中排位靠后的情况. 如果预期元素在较前的位置, 应该使用<see cref="M:ijw.Next.Collection.IListExt.IndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>扩展方法.
            </remarks>
        </member>
        <member name="M:ijw.Next.Collection.IListExt.IndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0},ijw.Next.Collection.FetchingStrategies)">
            <summary>
            根据枚举策略查找第一个符合指定条件的元素的索引
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="collection">列表</param>
            <param name="predicate">条件, 为真则返回</param>
            <param name="strategies">查找策略, 从后向前或者从前向后.</param>
            <returns>返回符合谓词的元素的索引, 如果没有符合的将会返回-1</returns>
            <remarks>
            内部实际上调用了IndexOf和LastIndexOf.
            如果预期元素在较前的位置, 应该使用<see cref="F:ijw.Next.Collection.FetchingStrategies.FirstFirst"/>, 反之是<see cref="F:ijw.Next.Collection.FetchingStrategies.LastFirst"/>.
            </remarks>
        </member>
        <member name="M:ijw.Next.Collection.IListExt.RemoveRange``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            从指定位置开始移除当前及其之后的所有元素
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="index">指定的索引处</param>
            <returns>移除的数目</returns>
        </member>
        <member name="T:ijw.Next.Collection.IListHelper">
            <summary>
            
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.IListHelper.ForEachPair``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},ijw.Next.ActionWithRef{``0,``1},System.Boolean,System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素的引用进行操作.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="action">需要对每对元素执行的操作，接受两个集合的元素引用作为参数。</param>
            <param name="forceDimensionMatching">如果为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <param name="ifCheckDimensionFirst">如果为true，会在迭代之前检查集合元素数量是否匹配。可与<paramref name="forceDimensionMatching"/>配合使用</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.IListHelper.ForEachPair``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},ijw.Next.ActionWithRef{``0,``1,System.Int32},System.Boolean,System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素的引用以及当前索引进行操作.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="action">需要对每对元素执行的操作，接受两个集合的元素引用以及当前索引作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <param name="ifCheckDimensionFirst">如果为true，会在迭代之前检查集合元素数量是否匹配。可与<paramref name="forceDimensionMatching"/>配合使用</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.IListHelper.ForEachThree``3(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``2},ijw.Next.ActionWithRef{``0,``1,``2},System.Boolean,System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素的引用进行操作.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <typeparam name="T3">第3个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="collection3">第3个集合</param>
            <param name="action">需要对每对元素执行的操作，接受两个集合的元素引用作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <param name="ifCheckDimensionFirst">如果为true，会在迭代之前检查集合元素数量是否匹配。可与<paramref name="forceDimensionMatching"/>配合使用</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.IListHelper.ForEachThree``3(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``2},ijw.Next.ActionWithRef{``0,``1,``2,System.Int32},System.Boolean,System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素的引用以及当前索引进行操作.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <typeparam name="T3">第3个集合里面元素的类型</typeparam>
            <param name="collection1">第1个集合</param>
            <param name="collection2">第2个集合</param>
            <param name="collection3">第3个集合</param>
            <param name="action">需要对每对元素执行的操作，接受两个集合的元素引用以及当前索引作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <param name="ifCheckDimensionFirst">如果为true，会在迭代之前检查集合元素数量是否匹配。可与<paramref name="forceDimensionMatching"/>配合使用</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="T:ijw.Next.Collection.ItemCountChangedEventArgs">
            <summary>
            集合元素数量变化事件参数
            </summary>
        </member>
        <member name="P:ijw.Next.Collection.ItemCountChangedEventArgs.ItemCount">
            <summary>
            集合元素数量
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.ListExt">
            <summary>
            
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.ListExt.RemoveRange``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            从指定位置开始移除当前及其之后的所有元素
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="index">指定的索引处</param>
            <returns>移除的数目</returns>
        </member>
        <member name="T:ijw.Next.Collection.LongTimeConsumerCollection`1">
            <summary>
            提供一个支持较长时间消费操作的线程安全集合.
            </summary>
            <typeparam name="T">元素类型</typeparam>
            <remarks>
             消费者可以随时追加元素, 也可以随时取出元素, 进行消费操作.
             消费后, 可以通过Remove方法控制移除对象, 满足长时间消费操作的需求.
             如果消费者最终无法完成消费操作, 可以调用Return将对象还回集合.
            </remarks>
        </member>
        <member name="E:ijw.Next.Collection.LongTimeConsumerCollection`1.ItemCountChanged">
            <summary>
            内部元素数量发生变化
            </summary>
        </member>
        <member name="P:ijw.Next.Collection.LongTimeConsumerCollection`1.ItemGettngStrategy">
            <summary>
            元素取出策略
            </summary>
        </member>
        <member name="P:ijw.Next.Collection.LongTimeConsumerCollection`1.Count">
            <summary>
            元素数量.
            </summary>
        </member>
        <member name="P:ijw.Next.Collection.LongTimeConsumerCollection`1.HasItem">
            <summary>
            获取是否存在元素
            </summary>
        </member>
        <member name="P:ijw.Next.Collection.LongTimeConsumerCollection`1.HasAvailableItems">
            <summary>
            获取当前是否存在未被提取消费的元素
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.LongTimeConsumerCollection`1.Append(`0)">
            <summary>
            向集合尾部追加一个元素
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:ijw.Next.Collection.LongTimeConsumerCollection`1.Remove(`0)">
            <summary>
            移除某个元素
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:ijw.Next.Collection.LongTimeConsumerCollection`1.Return(`0)">
            <summary>
            将指定元素交还给集合
            </summary>
            <param name="item">欲交还的元素</param>
        </member>
        <member name="M:ijw.Next.Collection.LongTimeConsumerCollection`1.TryBorrow(`0@)">
            <summary>
            尝试取出一个元素
            </summary>
            <param name="item">取出的元素</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:ijw.Next.Collection.LongTimeConsumerCollection`1.TryBorrowAvailable(`0@)">
            <summary>
            尝试借出一个可用元素
            </summary>
            <param name="item">取出的元素</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:ijw.Next.Collection.MutableTuple`2">
            <summary>
            可变的二元元组
            </summary>
            <typeparam name="T1">第一个元素的类型</typeparam>
            <typeparam name="T2">第二个元素的类型</typeparam>
        </member>
        <member name="M:ijw.Next.Collection.MutableTuple`2.#ctor(`0,`1)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:ijw.Next.Collection.MutableTuple`2.Item1">
            <summary>
            第一个元素
            </summary>
        </member>
        <member name="P:ijw.Next.Collection.MutableTuple`2.Item2">
            <summary>
            第二个元素
            </summary>
        </member>
        <member name="T:ijw.Next.Collection.ValueTupleExt">
            <summary>
            值元组的扩展方法
            </summary>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachPairSelect``3(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            对元组中两个集合的每一对元素执行指定的计算, 返回迭代器.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <typeparam name="TResult">函数计算返回值得类型</typeparam>
            <param name="tuple"></param>
            <param name="func">欲执行的计算。接受两个集合的元素对作为参数。</param>
            <returns>计算结果形成的集合（仅为迭代器，即并未即时进行计算。）</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">第1个集合的元素数大于第2个集合的元素数时会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachPairSelect``3(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,System.Int32,``2})">
            <summary>
            对元组中两个集合的每一对元素执行指定的计算，返回迭代器. 传递对应索引作为参数之一。
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <typeparam name="TResult">函数计算返回值得类型</typeparam>
            <param name="tuple"></param>
            <param name="func">欲执行的计算，接受两个集合的元素对以及当前索引作为参数。</param>
            <returns>计算结果形成的集合（仅为迭代器，即并未即时进行计算。）</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">第1个集合的元素数大于第2个集合的元素数时会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachPair``2(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}},System.Action{``0,``1})">
            <summary>
            对元组中两个集合的每一对元素执行指定的操作
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="action">欲执行的操作，接受两个集合的元素对作为参数。</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">第1个集合的元素数大于第2个集合的元素数时会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachPair``2(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}},System.Action{``0,``1,System.Int32})">
            <summary>
            对元组中两个集合的每一对元素执行指定的操作，传递对应索引作为参数之一。
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="action">欲执行的操作，接受两个集合的元素对以及当前索引作为参数。</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">第1个集合的元素数大于第2个集合的元素数时会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachPairWhile``2(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,System.Boolean},System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行操作.根据操作返回的值决定是否提前结束迭代.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="dowhile">需要对每对元素执行的操作，接受两个集合的元素作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <returns>执行了操作的最后一对元素的索引. 注意如果迭代是在到达第1个集合结尾之前就break出来的话，此项为相应的负值。因此可通过返回值的正负来判断是否进行完整的迭代。</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachPairWhile``2(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,System.Int32,System.Boolean},System.Boolean)">
            <summary>
            对两个集合进行同步迭代, 对每一对元素进行操作.根据操作返回的值决定是否提前结束迭代.
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="dowhile">需要对每对元素执行的操作，接受两个集合的元素对以及当前索引作为参数。</param>
            <param name="forceDimensionMatching">为true，会在操作后检查两个集合元素数是否不相等. 为false，不检查.</param>
            <returns>执行了操作的最后一对元素的索引. 注意如果迭代是在到达第1个集合结尾之前就break出来的话，此项为相应的负值。因此可通过返回值的正负来判断是否进行完整的迭代。</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">当1)集合2的元素数量小于集合1的元素数量，或2)<paramref name="forceDimensionMatching"/>为true，且两个集合元素数不相等时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachTwoInBetween``2(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}},System.Action{``0,``1})">
            <summary>
            对元组中两个集合的每一对组合对执行指定操作. 例如对于{1,2}和{a,b,c}, 将依次针对(1,a), (1,b), (1,c), (2,a), (2,b), (2,c)六种组合执行操作.
            <para>
            可以理解为嵌套for循环.
            </para>
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="tuple"></param>
            <param name="action">想要执行的操作. 接受两个参数, 第一个参数来自第一个集合, 第二个参数来自第二个集合.</param>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachTwoInBetweenSelect``3(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            对元组中两个集合的每一对组合对执行指定查询. 例如对于{1,2}和{a,b,c}, 将依次针对(1,a), (1,b), (1,c), (2,a), (2,b), (2,c)六种组合执行操作.
            <para>
            可以理解为嵌套for循环.
            </para>
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="tuple"></param>
            <param name="func">想要执行的计算. 接受两个参数, 第一个参数来自第一个集合, 第二个参数来自第二个集合.</param>
            <returns>每一个组合的计算结果组成的序列迭代器.</returns>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachThree``3(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2}},System.Action{``0,``1,``2})">
            <summary>
            对三个集合进行同步迭代, 对每一组（三个）元素进行指定操作.
            </summary>
            <typeparam name="T1">第一个集合里面元素的类型</typeparam>
            <typeparam name="T2">第二个个集合里面元素的类型</typeparam>
            <typeparam name="T3">第三个个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="doWork">执行的操作</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">集合1元素数大于集合2或集合3的元素数时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachThree``3(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2}},System.Action{``0,``1,``2,System.Int32})">
            <summary>
            对三个集合进行同步迭代, 对每一组（三个）元素以及索引进行指定操作.
            </summary>
            <typeparam name="T1">第一个集合里面元素的类型</typeparam>
            <typeparam name="T2">第二个个集合里面元素的类型</typeparam>
            <typeparam name="T3">第三个个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="doWork">执行的操作</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">集合1元素数大于集合2或集合3的元素数时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachThreeSelect``4(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2}},System.Func{``0,``1,``2,``3})">
            <summary>
            对三个集合进行同步迭代, 对每一组（三个）元素进行指定函数计算
            </summary>
            <typeparam name="T1">第一个集合里面元素的类型</typeparam>
            <typeparam name="T2">第二个个集合里面元素的类型</typeparam>
            <typeparam name="T3">第三个个集合里面元素的类型</typeparam>
            <typeparam name="TResult">函数计算返回值得类型</typeparam>
            <param name="tuple"></param>
            <param name="func">需要计算的函数</param>
            <returns>返回的结果迭代器</returns>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">集合1元素数大于集合2或集合3的元素数时, 会抛出 CountNotMatchException 异常.</exception>
            <remarks>
            本函数只返回一个迭代器.计算将延迟在对结果的迭代访问时进行.
            </remarks>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachPair``2(System.ValueTuple{System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1}},ijw.Next.ActionWithRef{``0,``1})">
            <summary>
            对元组中两个集合的每一对元素执行指定的操作
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="action">欲执行的操作，接受两个集合的元素引用作为参数。</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">第1个集合的元素数大于第2个集合的元素数时会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachPair``2(System.ValueTuple{System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1}},ijw.Next.ActionWithRef{``0,``1,System.Int32})">
            <summary>
            对元组中两个集合的每一对元素执行指定的操作，传递对应索引作为参数之一。
            </summary>
            <typeparam name="T1">第1个集合里面元素的类型</typeparam>
            <typeparam name="T2">第2个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="action">欲执行的操作，接受两个集合的元素引用以及当前索引作为参数。</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">第1个集合的元素数大于第2个集合的元素数时会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachThree``3(System.ValueTuple{System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``2}},ijw.Next.ActionWithRef{``0,``1,``2})">
            <summary>
            对三个集合进行同步迭代, 对每一组（三个）元素进行指定操作.
            </summary>
            <typeparam name="T1">第一个集合里面元素的类型</typeparam>
            <typeparam name="T2">第二个个集合里面元素的类型</typeparam>
            <typeparam name="T3">第三个个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="doWork">执行的操作</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">集合1元素数大于集合2或集合3的元素数时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
        <member name="M:ijw.Next.Collection.ValueTupleExt.ForEachThree``3(System.ValueTuple{System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``2}},ijw.Next.ActionWithRef{``0,``1,``2,System.Int32})">
            <summary>
            对三个集合进行同步迭代, 对每一组（三个）元素以及索引进行指定操作.
            </summary>
            <typeparam name="T1">第一个集合里面元素的类型</typeparam>
            <typeparam name="T2">第二个个集合里面元素的类型</typeparam>
            <typeparam name="T3">第三个个集合里面元素的类型</typeparam>
            <param name="tuple"></param>
            <param name="doWork">执行的操作</param>
            <exception cref="T:ijw.Next.Collection.CountNotMatchException">集合1元素数大于集合2或集合3的元素数时, 会抛出 CountNotMatchException 异常.</exception>
        </member>
    </members>
</doc>
